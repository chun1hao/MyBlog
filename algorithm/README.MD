## 时间复杂度
程序运行从开始到结束所需要的时间

### 常见时间复杂度：
- O(1): 常数阶 
```
  没有循环语句
 ```
- O(n): 线性阶 
```
  一重循环
 ```
 - O(log n): 对数阶
 ```
 var number = 1
while(number < 100){
    number *= 2
}
// 假设循环次数为 x，2^x = n, x = log2n, 即 O(logn)
// 一般为 n 除以一个常数，经过多少次等于1或者0，比如常见的二分查找法
 ```
 - O(n^2): 平方阶
 ```
// 常见两层循环
for(let i=0;i<n;i++){
    for(let j=i;j<n;j++){
      ......
    }
}
// n+n-1+n-2+n-3+...+3+2+1
// n+n(n-1)/2
// n/2+n^2/2 
// 保留最高阶 n^2*1/2 当n足够大的时候 n/2 忽略不计
// 去掉常数 n^2
 ```
 - O(n^3): 立方阶
 - O(2^n): 指数阶
 - O(n!):  阶乘阶 
 
 *O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2ⁿ) <O(n!)*
 
## 空间复杂度
运行完一个程序所需内存的大小

假设原始数据大小为n，一个算法需要m大小的内存才能运行，那么我们就有一个函数f(n)=m。这个函数去掉常数项和尾数项就是空间复杂度

比如说，如果用冒泡排序对数据排序，如果直接在原始数据上排，那么根本不需要额外的存储空间，而最多只需要定义几个变量，那么复杂度就是1
如果排序产生一个新的数组，不修改原来的数组，那么对于排序n个数据，就需要n个新的存储空间，那么复杂度就是n。

如果需要一个辅助数组，空间复杂度为O(n)
如果需要一个二维的辅助数组，空间复杂度为O(n^2)
对于递归，空间复杂度等于递归深度

## 推算方法
1. 用常数1来取代运行时间中所有加法常数。
2. 修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。


## [经典排序](https://github.com/chun1hao/MyBlog/blob/master/algorithm/sort.js)

![image](https://github.com/chun1hao/MyBlog/blob/master/algorithm/%E5%A4%8D%E6%9D%82%E5%BA%A6.png)
  
小总结：
1. 在所有排序中，快速排序是最快的排序方法
2. 如果有大量重复元素，可以选择三路快排
3. 近乎有序的，可以选择插入排序
4. 取值范围有限（跨度不大的情况），可以选择计数排序
5. 如果需要稳定排序，可以归并排序

对于有序数组查找是否包含某个元素可以使用二分查找法，其时间复杂度为 O(logn)
```javascript
function binarySearch(arr, target){
    let len= arr.length, l = 0, r = len-1;
    while(l <= r){
        let mid = Math.floor((l+r)/2)
        if(arr[mid] == target){
            return mid
        }else if(arr[mid] < target){
            l = mid + 1
        }else{
            r  = mid - 1
        }
    }
}
```
