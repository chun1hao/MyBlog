### TCP/IP 协议族
HTTP协议是 TCP/IP 的一个子集  
TCP/IP协议族按层次分为以下四层
- 应用层：应用层规定了向用户提供应用服务时通信的协议，如：FTP（文件传输协议）、 DNS（域名系统）以及HTTP协议
- 传输层：传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议（TCP，UDP）
    - TCP 是全双工的，即发送数据和接收数据是同步进行的，建立需要三次握手和断开连接需要四次挥手，传输稳定可靠，但没UDP那么高效
    - UDP协议是面向无连接的，即传递数据前不需要建立连接，所以UDP协议比TCP更加高效和轻便，同时不够稳定
- 网络层：网络层规定了数据通过怎样的传输路线到达对方计算机
- 链路层：处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、网卡，及光纤等物理可见部分

### 三次握手
- 客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c)
- 服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传
- 为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值

### 四次挥手
- 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据
- 服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作
- 服务端发起自己的FIN段，ACK=K+1, Seq=L 
- 客户端确认，ACK=L+1

> 关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送

### HTTPS

**http 存在问题**  
1.  报文使用明文发送，可以被抓包工具截获
2. 无法确认身份，发送的服务器可能不是目标服务器，无法确定是否有访问权限
3. 在传输过程中信息可能被篡改，即中间人攻击

https 在 http 下加入 SSL 层，对传输数据进行加密  
1. 对称加密：通信双方使用同一个密钥进行加密和解密，密钥可能被截获
2. 非对称加密：生成一对：生成一对 公钥 和 私钥，公钥加密的只能用私钥解，通信交换公钥，然后使用对方的公钥对发送的信息进行加密，对方收到后使用自己的私钥解密，算法太慢
3. 非对称加密 + 对称加密：使用非对称加密 交换 对称加密 密钥，然后后续通信使用对称加密的密钥传输和解密 

https 第三种方式，但是任然不能避免中间人攻击：
中间人截获了公钥，然后传送给对方自己公钥

**数字签名**  
将公钥和个人信息（即原始信息）使用hash算法生成摘要（只要原始信息发生改变，摘要会发生巨大变化），防止修改原始内容  
任然可能被中间人截获然后将原始信息全部替换生成新的摘要

**数字证书**   
将公钥和个人信息使用 hash 算法生成摘要，再使用 CA 认证私钥加密生成 数字签名，最后将 数字签名 和 原始信息 合并生成数字证书
接受到证书后对原始信息使用  hash 算法生成 摘要，在用 CA 公钥对 数字签名 解密，得到数字签名，对比两个摘要
![Image text](http://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UJFk4ma5Y5g5wIeggZaCZ3xKYfzxv54kPQ9q9SKRPHpnVib9MF6MfPcLJgej3wicCVZSicUMNzoVasiaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 报文
整体结构：报文首部 + 空行 + 报文实体

| 通用首部 | 作用（请求报文和响应报文都可能使用）  |
|  ----  | ----  |
| Cache-Control  | 控制缓存的行为：no-cache（强制向服务器再次验证）、no-store（不做任何缓存）、max-age=111111（资源可缓存最大时间 秒）、public（客户端、代理服务器都可利用缓存）、private（代理服务器不可用缓存） |
|  Connection  | 浏览器想要优先使用的连接类型： keep-alive close（开启和关闭持久连接）  |
|  Date  | 创建报文时间  |
|  Transfer-Encoding  | 传输编码方式：chunked分块传输  |

| 请求首部 | 作用  |
|  ----  | ----  |
|  Accept  | 能正确接收的媒体类型：application/json text/plain  |
|  Accept-Encoding  | 能正确接收的编码格式列表：gzip deflate  |
|  Accept-Language  | 能正确接收的语言列表：zh-CN,zh;q=0.9  |
|  Authorization  | 客户端认证信息：Bearer dSdSdFFlsfdjasd123，一般存token用  |
|  Cookie  | 发送给服务器的Cookie信息  |
|  Host  | 服务器的域名，用于区分单台服务器多个域名的虚拟主机，是HTTP/1.1唯一必须包含的字段。  |
|  If-Match  | 两端资源标记比较，只有判断条件为真服务端才会接受请求：If-Mach: "123456，和服务端文件标记比较  |
|  If-Modified-Since  | 本地资源未修改返回 304（比较时间）  |
|  If-None-Match  | 本地资源未修改返回 304（比较标记）  |
|  User-Agent  | 客户端信息，操作系统、浏览器等信息  |
|  Range | 请求某个内容的一部分（断点续传） |
|  Referer  | 包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的  |

| 响应首部 | 作用  |
|  ----  | ----  |
|  Accept-Ranges  | 告知客户端服务器是否可接受范围请求，是bytes，否none  |
|  Age  | 资源在代理缓存中存在的时间  |
|  ETag  | 资源标识，资源发生变化时标识也会发生改变  |
|  Server  | 服务器名字  |

| 实体首部 | 补充请求报文或响应报文相关信息  |
|  ----  | ----  |
|  last-modified  | 响应首部，服务器认定的资源做出修改的日期及时间  |
|  Content-Type  | 内容的媒体类型（'application/json;charset=UTF-8'）  |
|  Expires  | 内容的过期时间  |

### 请求方法
1. get：一般用于请求资源
2. post：同 get，不同在于传递参数方式不同
3. put：更新数据，幂等
4. head：请求获取资源的响应消息报头
5. delete：删除
6. options：获取当前URL支持的方法
7. trace：用于激发一个远程的，应用层的请求消息回路
8. connect：请求连接转换到TCP/TP通道

**post 与 get 区别**（[w3cschool](https://www.w3school.com.cn/tags/html_ref_httpmethods.asp)）
|     | GET  | POST  |
|  ----  | ----  | ----  |
| 后退按钮/刷新  | 无害 | 数据会被重新提交（浏览器应该告知用户数据会被重新提交） |
| 书签  | 可收藏为书签 | 不可收藏为书签 |
| 缓存  | 能被缓存 | 不能缓存 |
| 编码类型  | application/x-www-form-urlencoded | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码 |
| 历史  | 参数保留在浏览器历史中 | 参数不会保存在浏览器历史中 |
| 对数据长度的限制  | 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符） | 无限制 |
| 对数据类型的限制  | 只允许 ASCII 字符 | 没有限制。也允许二进制数据 |
| 安全性  | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分 | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 |
| 可见性  | 数据在 URL 中对所有人都是可见的 | 数据不会显示在 URL 中 |

标准总结：
- GET 用于获取信息，是无副作用的，是幂等的，且可缓存
- POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存

实际上，GET 和 POST 方法没有实质区别，只是报文格式不同。  
GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。


### 状态码
1. 1xx：信息，服务器收到请求，需要请求者继续执行操作
    - 100 Continue，表示请求已接收，继续处理

2. 2xx：成功，操作被成功接收并处理
    - 200 OK，请求成功
    - 202 Accepted，已接受。已经接受请求，但未处理完成
  
3. 重定向，需要进一步的操作以完成请求
    - 301 Moved Permanently，永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
    - 302 Found，临时移动。与301类似。但资源只是临时被移动，在重定向的时候改变 method: 把 POST 改成 GET
    - 304 Not Modified，未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
    - 307 Temporary Redirect，同样为临时移动，在重定向时不会改变 method
    
4. 客户端错误，请求包含语法错误或无法完成请求
    - 400	Bad Request	客户端请求的语法错误，服务器无法理解
    - 401	Unauthorized	请求要求用户的身份认证
    - 403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求
    - 404	Not Found	服务器无法根据客户端的请求找到资源（网页）
    - 405	Method Not Allowed	客户端请求中的方法被禁止
    - 408	Request Time-out	服务器等待客户端发送的请求时间过长，超时
    - 415	Unsupported Media Type	服务器无法处理请求附带的媒体格式

5. 服务器错误，服务器在处理请求的过程中发生了错误
    - 500	Internal Server Error	服务器内部错误，无法完成请求
    - 502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
  
### 代理服务器
代理服务器就是客户端和服务端之间的“中间商”，即HTTP请求通过代理服务器转发给服务器，再将服务器的响应返回给客户端的行为。代理服务器可以用来作为缓存服务器，也可以用来隐藏用户身份（正向代理）或者服务器身份（反向代理）增加安全性  
- 正向代理：客户端向代理服务器发出请求，并指定目标访问服务器，然后代理服务器向源服务器转交需求，并将获得的内容返回给客户端，过程中隐藏了真实请求的客户端，服务端不知道真实请求客户是谁
- 反向代理：客户端发向反向代理出请求，反向代理服务器收到需求后判断请求走向何处，然后再将结果反馈给客户端，隐藏了了内部服务器的信息
  - 反向代理解决跨域：原理是浏览器有同源策略的限制，但服务器是没有的同源策略的限制，本地服务要请求服务器的资源的时候，我们不直接请求服务器，而是请求本地服务自身（这时是同源请求，不存在跨域），本地代理服务再将接口转发给目标服务器（注意这时候是两个服务器直接的通信了，而不是客户端和服务器的通信，所以更不存在跨域），本地服务获取到目标服务器的响应数据之后通过再代理伪装成本地服务请求的返回值返回给客户端
  
### 缓存
浏览器缓存保存着用户通过 HTTP 获取的所有资源，再下一次请求时可以避免重复向服务器发出多余的请求  
缓存可以分为两类：强缓存 和 协商缓存，浏览器在加载资源时，会先判断是否命中强缓存再验证是命中协商缓存  
1. 浏览器发送请求前，根据请求头的 expires 和 cache-control 判断是否命中强缓存策略，如果命中，直接从缓存获取资源，不会发送请求
2. 如果没有命中强缓存规则，浏览器会发送请求，根据请求头的 last-modified 和 etag 判断是否命中协商缓存，如果命中，直接从缓存获取资源
3. 如果前两步都没有命中，则直接从服务端获取资源

![Image text](https://github.com/chun1hao/MyBlog/blob/master/base/cache.png)

- 强缓存：不会向服务器发送请求，直接从缓存中读取资源，就是向浏览器缓存查找该请求结果，来决定是否使用该缓存的过程
    - Expire：缓存过期时间(绝对时间)，用来指定资源到期的时间，是服务器端的具体的时间点。Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
    > Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效
    - Cache-Control：
        1). max-age=<seconds>：资源能够被缓存的最大时间。max-age是距离请求发起的时间的秒数
        2). public：所有内容都将被缓存（客户端和代理服务器都可缓存）
        3). private：所有内容只有客户端可以缓存，Cache-Control的默认取值
        4). no-cache：不是强缓存，需要发送请求到服务器确认是否使用缓存（协商缓存）
        5). no-store：禁止使用缓存，每一次都要重新请求数据
        > 设置了no-cache之后，不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而no-store才表示不会被缓存，即不使用强制缓存，也不使用协商缓存
     
     > 同时设置 Expire 和 Cache-Control 后，Cache-Control 的优先级别更高
     > 缓存存放：from disk cache(磁盘缓存，容量大，读取慢)、from memory cache(内存缓存，容量小，读取快)。如果开启了Service Worker首先会从Service Worker中拿；对于大文件来说，大概率是不存储在内存中的，反之优先；当前系统内存使用率高的话，文件优先存储进硬盘
     > 读取顺序：memory –> disk
     
- 协商缓存：强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，如果命中返回 304 
    - Last-Modified 和 If-Modified-Since
        1). 浏览器首先发送一个请求，让服务端在响应头中返回请求的资源上次更新时间，就是last-modified，浏览器会缓存下这个时间
        2). 然后浏览器再下次请求中，请求头中带上if-modified-since:[之前保存的last-modified的值]。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗
        
        > 保存的是绝对时间,最小单位是秒。也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化；
        > 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为
    
    - ETag 和 If-None-Match
        1). 浏览器会先发送一个请求得到 etag 的值，然后再下一次请求在请求头中带上if-none-match:[保存的etag的值]。
        2). 通过发送的 etag 的值和服务端重新生成的 etag 的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源
        
        > etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，所以 etag 会增加消耗
        
    - Etag 优先级高于 Last-Modified

- 用户行为
    - 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求
    - 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache
    - 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容

- 应用
    变化频繁的使用 协商缓存，不常变化的使用 强缓存

### CDN
不使用 CDN 时访问网站过程：  
1. 用户向浏览器提供要访问的域名；
2. 浏览器调用域名解析函数库对域名进行解析，以得到此域名对应的IP地址；
3. 浏览器使用所得到的IP地址，域名的服务主机发出数据访问请求；
4. 浏览器根据域名主机返回的数据显示网页的内容

使用CDN的访问形式：  
1. 用户向浏览器提供要访问的域名；
2. 浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库得到的是该域名对应的CNAME记录（由于现在已经是使用了CDN服务，CNAME为CDN服务商域名），为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。（CDN服务来提供最近的机器）
3. 此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器发出访问请求
4. 缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求
5. 缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程；
6. 客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程

回源：当 cdn 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源








